# Incremental compuotation

## モチベーション1: エフェクトシステムや代数的エフェクトなどとの関連

メモ化はアルゴリズムに対するものとしての意味合いが大きくて、実装方法はナイーブ。
Incremental computationはアイデアは似ているけど、計算の種類がことなるイメージ。
アルゴリズムではなく、もっと複雑な大きい計算（ソフトウェア）が該当しそう。

### 計算が純粋なとき

計算 `\x.C(x)` があったとき、過去に `C(a)` を計算した結果と、今 `C(b)` を計算した結果が一致するかが気にするべきことで、
そのような性質を満たすような `C` のとり方とか、性質をいかに軽量に保証するかとかが頑張りどころだろう。

`C` が純粋なら、引数が一致すれば計算結果は一致する。
引数が一致しなくても計算結果が一致する可能性がある。
そのときは、`C` で定まる定義域の同値類をとって、
`C : A -> B` に対して `C~ : A/C -> B` を考えれば、`C~` の計算結果の一致/不一致は引数のそれと対応する。
なので、`C~` を定義できて、`f: A -> A/C` も定義できれば、再計算の必要性を `f` の実行と `C~` のメモ化だけで最も細かく判定できる。

普通は `C` から `C~` みたいなものは計算できないのだろうが。できるとしたら、多くのケースでそれぞれの同値類に対応する `B` での値も定まるだろう。
そうなれば辞書として `C~` をもっておけばよい。
`C` の計算結果を全域で計算しなくても、`C~` （やそれに近いもの）を定義できるならこの手法は生きるかもしれない。

### 純粋ではないとき

副作用がどうこうで計算結果の再利用ができるかが決まる。
副作用には外の環境が計算に影響を及ぼすケースと、計算が外の環境に影響するケースがある (`set` v.s. `get`, `cin` v.s. `cout` など)。

環境が違って、それを参照する計算の結果が違うことを心配するなら、
環境を計算の引数だと思うことで純粋なケースと同じ考え方を適用できる。

計算が環境に影響をおよぼすケースでは、計算結果を値を返すだけでなく、環境への作用も再現しないといけない。
モナドでは、環境への影響を表現して、bindがその結果を反映するための解釈を定める。

したがって、モナドを使えば純粋なケースでの手法を副作用があるケースでも流用できそうだ。
モナドに限らず、イベントをファーストクラスの値として扱えれば副作用を純粋な関数の引数や返り値として扱える。
代数的エフェクトは、ハンドラの内側ではいわゆる命令みたいな書き方を許しつつ、ハンドラを含む外側ではイベントみたいな捉え方をできるように振る舞える。
モナドよりもプログラマフレンドリな書き方を許せるかもしれない。

### 課題

どちらのケースでも、良い `C` の定義域の割り方と、軽量な同値判定 `f` を与えるのが課題だろう。
僕の中では以下が気になっていた:

- 代数的エフェクトはどれくらい役立てられるだろうか
    - モナドでの既存研究と組み合わせるか。UIを代数的エフェクトに置き換える。
    - ReactやElmが近いか
        - とりあえず、これらに追いつくことを考えるか？
        - [ ] incremental な仕組みと、プログラマが触る部分の分離、プログラマの体験
        - [ ] ReactやElmはwebフレームワークだが、そこにこだわる必要はどこから生じたのか。他に適用できるものはないか。
- エフェクトシステムはどのように役立つか
    - 計算の副作用の内容が静的にわかれば、コンパイル時に細工できて嬉しいくらいか。
      どのような細工をしたくなるだろうか。
      Regioned Javaは並列アルゴリズムの決定性をエフェクトシステムで保証する、みたいな研究。再利用は扱わないだろうが、Incremental computationで気になるのは決定性だろう。その点で関連している。
    - 計算と環境との間で、引数以外で気になる依存性はメモリの状態くらいではないだろうか。
      それ以外の副作用を含む計算で、incremental computationの恩恵に預かりたいものはあるだろうか。
      メモリの状態は普遍的だから、抽象度が低いという考え方がありうる？
      一般的だけど、使い勝手を良くするにはそこからさらに工夫が必要とか？
      そこで僕が頑張れることはあるか？
      ユースケースを考えて、特定の領域の問題をきれいに解決する？
        - [ ] ユースケースを特に思いつかない


エフェクトシステムはどれくらい影響を与えるかとか、代数的エフェクトがあるときに、エフェクトシステムとともにどのような嬉しさを見いだせるかを考えたい。

副作用に代数的エフェクトだけを用いると、外部への依存性はパラメータとエフェクトハンドラだけになる。
エフェクトハンドラでは依存性が生じた時点での継続をとれる。言い換えると依存性が生じる以前の計算を反映した評価文脈が得られる。
普通のincremental computationがどうしているかは定かではないが、特定の関数の引数をみるとか、もっと大きな単位のスレッドみたいなもののパラメータをみて、それらを再実行するか判断するのではないだろうか。
そう思うとエフェクトハンドラを用いるときめ細かい分割ができるし、おそらくそれよりも大事なこととして本当に依存性が発生する部分を（割とプログラマの手を煩わせないやり方で）切り出せる。

懸念は代数的エフェクトと相性が良いエフェクトはincremental computationで外部と依存したくなるようなものか、ということ。
可変状態は別にエフェクトハンドラでやることはないだろう。コントロールフローが絡んでくるとエフェクトハンドラが便利な感じがする。

エフェクトシステムとincrementalの相性は良さそう。こちらはエフェクトハンドラとどれくらい絡みがでるだろうか。
基本はメモリ管理な気がする。
そもそもincrementalではフレームワークにどれくらい期待するだろうか。今までの環境での辛みを知りたい。

# 資料

次はどちらもたくさん引用されている。

- [A Type and Effect System for Deterministic Parallel Java (OOPSLA2009)](https://dl.acm.org/doi/abs/10.1145/1640089.1640097?casa_token=FJRQiTuakakAAAAA:9yPqcV7vMTU28fWrNR3hDK9X0qyrdUF3E9GcRmxqhO-ZIMnLXFEaEUDPQbtNeN2t6i48-J_sBNjhJPU)
- [Monads for incremental computing (ICFP2002)](https://dl.acm.org/doi/abs/10.1145/581478.581482)

MultiCore OCamlでconcurrent programmingの話。incrementalとはあまり関係ない？

- [(github)](https://github.com/ocamllabs/ocaml-effects-tutorial)
- [Concurrent System Programming with Effect Handlers](https://link.springer.com/chapter/10.1007/978-3-319-89719-6_6) (need VPN)

Incremental for compiler.
--
