# incremental

Incremental computationのサーベイ。
メモ化はアルゴリズムに対するものとしての意味合いが大きくて、実装方法はナイーブ。
Incremental computationはアイデアは似ているけど、計算の種類がことなるイメージ。
（一般の）ソフトウェアに対するものが該当しそう。

副作用がどうこうで計算結果の再利用ができるかが決まる。エフェクトシステムはどれくらい影響を与えるかとか、代数的エフェクトがあるときに、エフェクトシステムとともにどのような嬉しさを見いだせるかを考えたい。

副作用に代数的エフェクトだけを用いると、外部への依存性はパラメータとエフェクトハンドラだけになる。
エフェクトハンドラでは依存性が生じた時点での継続をとれる。言い換えると依存性が生じる以前の計算を反映した評価文脈が得られる。
普通のincremental computationがどうしているかは定かではないが、特定の関数の引数をみるとか、もっと大きな単位のスレッドみたいなもののパラメータをみて、それらを再実行するか判断するのではないだろうか。
そう思うとエフェクトハンドラを用いるときめ細かい分割ができるし、おそらくそれよりも大事なこととして本当に依存性が発生する部分を（割とプログラマの手を煩わせないやり方で）切り出せる。

懸念は代数的エフェクトと相性が良いエフェクトはincremental computationで外部と依存したくなるようなものか、ということ。
可変状態は別にエフェクトハンドラでやることはないだろう。コントロールフローが絡んでくるとエフェクトハンドラが便利な感じがする。

エフェクトシステムとincrementalの相性は良さそう。こちらはエフェクトハンドラとどれくらい絡みがでるだろうか。
基本はメモリ管理な気がする。
そもそもincrementalではフレームワークにどれくらい期待するだろうか。今までの環境での辛みを知りたい。

# 資料

次はどちらもたくさん引用されている。

- [A Type and Effect System for Deterministic Parallel Java (OOPSLA2009)](https://dl.acm.org/doi/abs/10.1145/1640089.1640097?casa_token=FJRQiTuakakAAAAA:9yPqcV7vMTU28fWrNR3hDK9X0qyrdUF3E9GcRmxqhO-ZIMnLXFEaEUDPQbtNeN2t6i48-J_sBNjhJPU)
- [Monads for incremental computing (ICFP2002)](https://dl.acm.org/doi/abs/10.1145/581478.581482)

MultiCore OCamlでconcurrent programmingの話。incrementalとはあまり関係ない？

- [(github)](https://github.com/ocamllabs/ocaml-effects-tutorial)
- [Concurrent System Programming with Effect Handlers](https://link.springer.com/chapter/10.1007/978-3-319-89719-6_6) (need VPN)

Incremental for compiler.

IDEでフィードバックをするための言語処理系の正しさと実行効率を追求したい。
理論はおそらくあまりなくて、エンジニアリングの要素が大きいイメージ。
データの持ち方やキャッシュ方針、対応するクエリ(e.g.,LSP)などの設計と実装。
理論的にやってもおもしろいとは思う。
lambda calculusには型推論や型判断アルゴリズムがたくさんある。ここで、部分的な変更があったときにどれだけ計算量を減らせるかを考える。
データ構造の設計や変更の定式化がチャレンジングになるだろう。当然対応する差分をうまくハンドルするアルゴリズムも必要。
lambdaでどれくらいのクエリを形式化できるだろうか？pure-LCではいろいろ厳しそう。SML-NGはどうか？理論的な側面を強く推したいならこれくらい？

rust-analyzerを見ていると、ある程度クセのある抽象化で難しさが出てくるけど、C++やOCamlみたいに宣言が先にきて、それを参照するスタイルの言語ではキャッシュの利用が楽だとのこと。
式レベルで差分コンパイルをしても嬉しくないのかも知れない。関連して気になるのがVSCodeのC/C++のシンタックスハイライト。おそらくローカル変数の参照を解析して、束縛されていることを確かめてから色をつけている。その割に色の変化がおとなしい。Viewの部分でうまい事やっているのか？

このあたりでやることがあるかを調べたい。そのためにいかが気になる：

- IDEではどのくらいの速度がでているのか
    - それはレスポンシブか
- IDEのコンパイラはどれくらい正確か
    - 上限がホントのコンパイラ？その振る舞いとの差分がどれくらいかを見れば良い？
    - 静的解析ツールはコンパイラにない警告とかを出す。それはどう扱うか？
    - 今回気にするのはどういう機能/ エラー/警告の報告？
- 実装方針はどんな感じか
    - 僕が頑張る余地はあるか
    - 頑張りたいと思えるたぐいのものか。無給で良いからやりたいと思えないといけない。

Language server はこの手のものだと思う。LSPで定めるAPIはそんなにたくさん実行されない？せいぜい人間が見たいときに叩くくらい。
もっとたくさんの頻度で叩きたくならないだろうか。Goはいい線いっている。IntelliJを試さないといけないか。
なやみどころにたどり着くまでが結構しんどそう。
形式検証的なことをコンパイラに近づけるとか？形式検証をインタラクティブに回す欲求はないか？
依存型ではどうだろうか？そういえばあれやばいかも。Coqは `.` とかで区切って、証明木を部分的に保持することでインタラクティブに開発できる。
ファイルのそこまでのASTノードとか宣言をすべて読み込んでいる。なので、ファイルの途中を変更すると、そこから先はすべて読み込み直しになったはず。
ということはCoqはあとの定義を前では使えない？
Coqの証明読み込みで無効化する部分を局所化する方法、あるいは、それを妨げる要因の特定と回避する現実的なデザインの提案など。

- [Three Architectures for a Responsive IDE](https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html)
    - IDE向けコンパイラのざっくりとした構成。特にコード補完のための依存性解析について。
    - rust-analyzerは（少なくとも）2020年当時はfine-grainなincremental computingをしていたみたい。コンパイル単位が大きいのでindexを取るのが難しいからだとか。コンパイラの実行パスや部分的な実行結果を保存して再利用性を判定しているのだとか。
        - 具体的にどのような条件を観察しているか気になる。proc-macroの非決定性によるバグがあった、とは言っていたが、コンパイラで副作用が起きるケースはなかなかなさそう。非決定性由来のバグもそんなものあるのか、と驚いた。キャッシュ可能性を判定するために副作用のなさを保証したくなって、そのためにエフェクトシステムは強いことをできそう。コンパイラ最適化としてどのくらい自動でincrementalなことをできるか？Haskellはすでにできそうで、昔軽く調べたことがあるのだけれど、それらしい情報にはたどり着けなかった。せいぜいモナドでメモ化をおしゃれに関数に追加するくらい。
    - C++はヘッダファイルが、Javaはファイル単位の意味が良い仕事をしていてIDE向けのindexingに優しいとか。
- [Architecture of rust-analyzer](https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/architecture.md)
    - 開発者向けドキュメント。上の記事を読んでからこの記事を読んでいるの。今の所この順番で読んで良かったと思っている。
    - Kokaにもこんなドキュメントがあったら、と思わずにいられない。まあ、このドキュメントと実装が対応しているかはわからないが。
- [Why the Sorbet typechecker is fast](https://blog.nelhage.com/post/why-sorbet-is-fast/)
    - Ruby向けの型検査器の実装について。高速化のためのデザインを解説している。詳細ではなく方針。
    - Rustの記事でおすすめされていた。<https://rust-analyzer.github.io/blog/2020/05/18/next-few-years.html>

- [2022-06-13: oshima-sanの発表資料](https://croquet.io/greenlight/index.html?r=Tl5CeT0yKvZILQ0cGjUG)
    - Croquetや関連技術の紹介。話がうまいし、内容にも興味があった。製品のクオリティがやばい。僕はあれに貢献する技術を生み出せるだろうか？
    - real-time性がやばい
    - JS-hotloadingもすごい
    - すごい
