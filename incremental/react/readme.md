# Reactを参考に課題を見つける

チュートリアルを批判的に読んで、研究の課題を見つける。
この[チュートリアル](https://ja.reactjs.org/docs/state-and-lifecycle.html)を読んでいる。

## stateとライフサイクル

データは下向きに流れるのは大変わかり易くてよいと思うのだが、
２つの遠い親戚コンポーネントが関係を持って、片方の状態がもう一方に作用するケースでは表現能力が不足するだろう。
イベントを使って、中央集権的に処理するか、チャンネルみたいなP2Pなことをするのか、グローバルな状態をチャンネル風に使うのか。

(共通の祖先に状態をもたせるのがセオリーのよう）

## イベント処理

JS勉強メモ: `this.handleClick = this.handleClick.bind(this);` のような `bind` はクロージャのバインド。
JS では `this` がグローバル変数

```js
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    console.log('You clicked submit.');
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

> React を使う場合、一般的には DOM 要素の生成後に `addEventListener` を呼び出してリスナを追加する必要はありません。代わりに、要素が最初にレンダーされる際にリスナを指定するようにしてください。

とあるが、ソースコードで `onSubmit` プロパティの値に関数を指定しているのがそれ。
`addEventListener` でしかできないことはどうやって実現するのだろうか。複数のリスナを登録するなど。

TODO: JSのthisを完全に理解する [参考](https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/)

このセクションはJSの関数とオブジェクトに関するセクションで、リアクトの問題ではなさそう。
ここを理解せずに芯を喰った議論はできそうにないが。

## リストとkey

JSXの子要素としてリストを与えたり、ソースコードにreact要素を列挙したりできる。
これらの違いはどのように潰されるのだろうか。
A?. 列挙した場合はリストに変換される。React要素.props.childrenに束縛される。

Keyは差分検知に役立っているのだろう。

## フォーム

Reactのエンジンはイベントを発火せずにDOMの編集をできるのか

```
this.setState({
  [name]: value
});
```

`[...]` としないでベタ書きすると変数名がプロパティの名前になってしまう。

制御されたコンポーネントの必要性は分かるけど、実現方法がイケていない。
非制御コンポーネントとかいう概念があるそうで、そこでは解決されているのかもしれない。

最後のほうで紹介された、valueがnullである制御されたコンポーネントのインスタンスは、
ユーザからの入力がそのまま反映されるらしい。
これはそれまでの説明に反する。

```
// input の値は常にhi
ReactDOM.createRoot(document.getElementById('root')).render(<input value="hi" />);

setTimeout(function() {
  // 好きに入力できる
  ReactDOM.createRoot(document.getElementById('root')).render(<input value={null} />);
}, 1000);
```

デフォルトの動作が定義されているのだろう。

## 一般

### stateのしくみ

stateを使って明示的に変更箇所をしていする場合と、renderを使って新しいオブジェクト作り直す場合がある。
どちらも差分を検知できているようにみえる。おそらく一方が他方にマクロ展開的な仕組みで変換されているのだろう。
どちらが低レベルだろうか？（おそらくrenderが低レベルで、stateの変更はrootのrenderを呼び出す？）

### 所有者の変化

ポインタが指す先の所有者はなにになるのだろうか。
例えばタイルが直線状に並んだUIで、それぞれのタイルは可変な値を持つとする。タイルの表示はその値に依存するので、値の変更があれば、表示を変化させたい。
タイルの配置もタイルの値に依存させたい。例えば昇順に並べることにしよう。
タイル値をどこで所有するのが良いだろうか？

カプセル化を求めると、タイルに値を所有して欲しくなる。タイルの描画にはそれでよいが、タイルの整列には不十分だろう。
タイルの親要素がchilderensをソートしたいので、_値の変更のたび_にソートしたいはずだ。そのためにはすべてのタイルの値を自身のstateとして所有したくなるのだろう。

では、そのとおりにタイルの親が値を所有することにしよう。タイルにはpropsを経由して値を渡すことになる。
タイルで値を変更する際には渡されたsethogehoge関数を渡すことになる。そうすると、親がstateを変更して、該当タイルに新しいpropsの値をセットしてrenderするのでタイルの描画も書き換わる。実現はうまくいきそうだ 。

しかしカプセル化に失敗してしまっている。親が子供の変更をすべて知らないとならないのだから、親が子供に依存するのはまっとうなのだろうが、
配置を変更できるようにするために、表示の依存先が変わるのが気持ち悪い。プログラミングの問題か。

はじめから状態の変更を要求するインターフェースを一つだけ定義しておいて、ハンドラを実装の都合に応じて変化させれば気持ち悪さが軽減しそう。

所有者とsetterは分けて考えるのが衛生的ではないだろうか？reactのやり方だと、所有者が上に居て、setterが下にいる。所有者がsetterまでの親子関係の間で、setするためのcapabilityを渡す。この状況は気持ちが悪い。setできるのは末端のsetterだけだと思いたくないだろうか？それにいちいち文脈を持ち回るのも気持ちが悪い。

この気持ち悪さは、reactに見せる状態の所有者（上で言う所有者）と、概念的な値の所有者（上で言うsetter）が異なっていることに起因する。
概念的な所有者以外にsetterの権限を渡したくない気持ちがあるのに、reactの流儀ではパス上のすべてが権限を持っていることが気持ち悪さの原因だろう。

#### レンダリングについて疑問

カードをスワップする際に、カード自体ののコンテンツに再描画は必要なのだろうか？
不要であってほしくて、カードだけに関したDOM的なものがあれば良いはずなので大丈夫だと思う。

#### 解決策

- Contextのセクションで紹介されている、contextを使わない情報の子孫への伝搬の手法に、遠い子孫を自身が作成し、propとして渡してしまうアイデアが有効かもしれない。
    - [Before You Use Context](https://reactjs.org/docs/context.html#before-you-use-context)
    - stateを定義と変更のコードが近づくし、その責任は一箇所になるので気持ちがよさそう?
    - TODO contextの話はきれいに見えるが、ultimateな雰囲気がどことなくする。どこで変な感じを抱いたのだろう？


### 親が所有する状態を変化させたい汎用react要素

setterとpropertyを型レベルのコントラクトとして指定することになりそうだ。
どのくらいの表現力が必要なのだろうか？
型みたいなものだけで十分だろうか？
そもそもそのような汎用react要素は定義したくなるか？

### 再描画のタイミング

再描画が発火するための条件はなにか。stateを変更したり、renderを呼び直すと再描画される？それ以外は無い？

## つれづれ

- 木構造で画面を表現するのは適切か？
    - 画面のことは知らないが、DOMが木構造だから、reactが木構造なのはしょうがない？プログラマに優しいのは木か。
- 木構造でUIを表現するのは適切か？
    - イベントとかリスナとかハンドラは木構造を無視した概念と思えるか。全体をトラバースするセマンティクスを持っていて、情報の依存関係が木構造と対応しない（）感がある。

